<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言期末复习</title>
    <url>/2020/06/25/C%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;   <span class="comment">//整数</span></span><br></pre></td></tr></table></figure>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a,b;  <span class="comment">//单精度</span></span><br><span class="line"><span class="keyword">double</span> c,d; <span class="comment">//双精度，比单精度保存小数位数更多，占用空间也更大</span></span><br></pre></td></tr></table></figure>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c,d; <span class="comment">//字符型，有对应的ASSIC码</span></span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><a id="more"></a>  

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">N=<span class="number">10</span>;     <span class="comment">//C99之后，N也可以为变量</span></span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">//由N个整型元素构成的数组        </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 字符串</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> a[N]=“Hello, world!”; <span class="comment">//字符串以'\0'结尾</span></span><br></pre></td></tr></table></figure>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;    <span class="comment">//指向一个整型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">char</span> *q=&amp;b[<span class="number">0</span>];<span class="comment">//指向数组的指针</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>()</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br></pre></td></tr></table></figure>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line"><span class="keyword">while</span>()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h4 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<h4 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>();</span><br><span class="line"><span class="built_in">pow</span>(,);</span><br></pre></td></tr></table></figure>
<h4 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h4><h4 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>();</span><br><span class="line"><span class="built_in">strcpy</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
        <category>大一下考试资料</category>
      </categories>
  </entry>
  <entry>
    <title>Data Structure-Introduction 简介</title>
    <url>/2020/06/22/DataStructure1/</url>
    <content><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>&emsp;&emsp;在计算机科学中，<strong>数据结构</strong>（Data Structure）是计算机中存储、组织数据的方式。它研究的是数据的<strong>逻辑结构</strong>和数据的<strong>物理结构</strong>以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。</p>
<a id="more"></a>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>数组（Arry）</li>
<li>队列（Queue）</li>
<li>链表（Linked List）</li>
<li>栈（Stack）</li>
<li>树（Tree）</li>
<li>图（Graph）</li>
<li>堆（Heap）</li>
</ul>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Data Structure 数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Diary1</title>
    <url>/2020/07/12/Diary1/</url>
    <content><![CDATA[<h2 id="Don’t-prentend-hard-working"><a href="#Don’t-prentend-hard-working" class="headerlink" title="Don’t prentend hard working"></a>Don’t prentend hard working</h2><p>I found I am pretty busy these days, but when I looked back It seems that I didn’t finish to much work. Most of the time in my life, I didn’t do much useful work. Not only me, but a large number of people will find they just pretend they are hard working. Laziness is the human’s instinct. We love to stay in our safe zone and do meaningless work over and over again. But how can we jump out of our safe zone and avoid useless effort?    </p>
<a id="more"></a>
<p>In the first term in my college, I pay really plenty of time in study.  I force me to stay in the library and study. But do I really learn as much knowledge as I expected? Definitely not, Most of the time I just do the easy questions for times. For difficult questions, I never solve them. That makes me just standstill.  And the exams also tell me the truth that never pretends hard working.    </p>
<p>Maybe the first step will be hard, just like reading a new book, but when you over that hard time you will find you are at a new level.  Actually, I always know I am not good at writing, and I am so tired to try to improve it. That cause a long period stagnant. If you are reading this article, why not take your first step just like me, I believe we all can succeed after a REAL hard working</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Data Structure-Liner Structure 线性结构</title>
    <url>/2020/06/22/DataStructur2/</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>由同类型<strong>数据元素</strong>构成的<strong>有序序列</strong>的线性结构。</p>
<h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><a id="more"></a>
<p>1.初始化<br>2.根据位置查找元素<br>3.查找某个元素的位置<br>4.插入<br>5.删除<br>6.表长  </p>
<h2 id="普通线性表"><a href="#普通线性表" class="headerlink" title="普通线性表"></a>普通线性表</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>基本框架：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;                <span class="comment">//数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DataType *p;                 <span class="comment">//指向数据的指针</span></span><br><span class="line">        <span class="keyword">int</span> length;                  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        List(<span class="keyword">int</span> N);                 <span class="comment">//初始化，生成N个数据成员的表</span></span><br><span class="line">        <span class="function">DataType <span class="title">Find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>)</span></span>; <span class="comment">//根据位置查找元素</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(DataType data)</span></span>;   <span class="comment">//查找某个元素的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(DataType)</span></span>;       <span class="comment">//插入</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Deleate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>)</span></span>;  <span class="comment">//删除</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;            <span class="comment">//表长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><strong>基本框架：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">typrdef <span class="keyword">int</span> DataType;      <span class="comment">//定义数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">List</span>;</span> <span class="comment">//节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>                //节点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        List L;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LinkedList(<span class="keyword">int</span> N);           <span class="comment">//初始化</span></span><br><span class="line">        <span class="function">DataType <span class="title">Find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>)</span></span>; <span class="comment">//根据位置查找元素</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(DataType data)</span></span>;   <span class="comment">//查找某个元素的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(DataType)</span></span>;       <span class="comment">//插入</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Deleate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>)</span></span>;  <span class="comment">//删除</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;            <span class="comment">//表长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限制线性表"><a href="#限制线性表" class="headerlink" title="限制线性表"></a>限制线性表</h2><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><hr>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4>]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Data Structure 数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>编程题2</title>
    <url>/2020/07/08/%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>MOOC练习题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>
<a id="more"></a>  
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;用静态链表存储树，直接比较。比较树的时候可以用到递归算法，但是看到题目的数据是英文字母，说明最多也就26个数据，那就直接用两层循环吧，方便些一点…开整</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>        //树节点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Data;         <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">char</span> Left;         <span class="comment">//左儿子</span></span><br><span class="line">    <span class="keyword">char</span> Right;        <span class="comment">//右儿子</span></span><br><span class="line">&#125;T1[Max],T2[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InPut</span><span class="params">(TreeNode T[],<span class="keyword">int</span> n)</span></span>;                        <span class="comment">//输入函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(TreeNode T1[],TreeNode T2[],<span class="keyword">int</span> n)</span></span>;      <span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> root1,root2;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    root1=InPut(T1,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span> (n!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> root2=InPut(T2,n);</span><br><span class="line"></span><br><span class="line">    flag=Compare(T1,T2,n);</span><br><span class="line">    <span class="keyword">if</span> (flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Data;</span><br><span class="line">    <span class="keyword">char</span> Left;</span><br><span class="line">    <span class="keyword">char</span> Right;</span><br><span class="line">&#125;T1[Max],T2[Max];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InPut</span><span class="params">(TreeNode T[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(TreeNode T1[],TreeNode T2[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> root1,root2;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    root1=InPut(T1,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span> (n!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> root2=InPut(T2,n);</span><br><span class="line"></span><br><span class="line">    flag=Compare(T1,T2,n);</span><br><span class="line">    <span class="keyword">if</span> (flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InPut</span><span class="params">(TreeNode T[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;T[i].Data&gt;&gt;T[i].Left&gt;&gt;T[i].Right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[j].Left-<span class="string">'0'</span>==i||T[j].Right-<span class="string">'0'</span>==i)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j==n)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(TreeNode T1[],TreeNode T2[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)<span class="keyword">if</span> (T1[<span class="number">0</span>].Data!=T2[<span class="number">0</span>].Data)flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (T1[i].Data==T2[j].Data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> T1L=T1[i].Left-<span class="string">'0'</span>,T1R=T1[i].Right-<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> T2L=T2[j].Left-<span class="string">'0'</span>,T2R=T2[j].Right-<span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;T1L&lt;&lt;" "&lt;&lt;T1R&lt;&lt;" "&lt;&lt;T2L&lt;&lt;" "&lt;&lt;T2R&lt;&lt;" ";</span></span><br><span class="line">                <span class="keyword">if</span> (T1[T1L].Data!=T2[T2L].Data&amp;&amp;T1[T1L].Data!=T2[T2R].Data)flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (T1[T1R].Data!=T2[T2L].Data&amp;&amp;T1[T1R].Data!=T2[T2R].Data)flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//if (flag)cout&lt;&lt;"YES ";else cout&lt;&lt;"NO ";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Questions 编程题</category>
      </categories>
  </entry>
  <entry>
    <title>Diary2</title>
    <url>/2020/07/13/Diary2/</url>
    <content><![CDATA[<h2 id="Never-“purchase”-love"><a href="#Never-“purchase”-love" class="headerlink" title="Never “purchase” love"></a>Never “purchase” love</h2><p>Yesterday I watched a video in TED, it mainly talking about we shouldn’t Pursuit of love.  After seeing many cases in my life, I am starting to understand why that TED speaker’s speech makes sense.  Love is something that complicated than we thought.   </p>
<a id="more"></a>
<p>In my college life, some of my friends, they put themselves in a pretty low position to love their crush. But after a long time’s effort, what the got? Nothing! If you love someone, never act like crazy fans are star chasing.  Love needs a balance that two sides pay equally. I am going to tell you a story about one of my friends. A girl has a crush on him, and she does anything she can to dram the boy’s attention. She buys a lot of gifts for boy and tries hard to show her shiny point. Did she make that? Yes, she got what she wants in the end. But do the boy love her? No, he does that just because he felt guilt. He doesn’t want to owe for her. I believe we all know the story’s ending. After a few weeks of getting along, they finally break up because the boy doesn’t love that girl at all.   </p>
<p>From my point of view, we shouldn’t see love as a product that can trade. Love is a distinctive gift from God,  and remember to keep it in awe!</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Diary3</title>
    <url>/2020/07/15/Diary3/</url>
    <content><![CDATA[<h2 id="人际关系中的价值对等"><a href="#人际关系中的价值对等" class="headerlink" title="人际关系中的价值对等"></a>人际关系中的价值对等</h2><p>&emsp;&emsp;前段时间，听到几个亲戚在讨论人脉，中国确实是一个充满“人情味”的国家，在社会上生存也的确需要有很好的人脉。但是看到网络上、畅销书上都在鼓吹人脉的作用，我就不经产生怀疑了，人脉的作用是不是被我们夸大了呢？也许我们应该看看人脉的本质是什么。</p>
<a id="more"></a>  
<p>&emsp;&emsp;人脉是什么，你认识什么人吗？绝对不是，你说你认识某某公司的老总、哪个国际著名影星，但是人家根本不认识你，这样也算不上人脉。我理解的人脉是一种互惠互利的关系，而不是某一方的单纯索取，这也是我为什么这次题目要取人际关系的价值对等。在一段良好的人际关系中，双方必须价值对等。就像网络上有一句俗语“舔狗最终一无所有”，一个青年为了追自己的“女神”卑微的像一条狗一样，倾其所有对女方付出，最后这样的关系大多都惨淡收场。其实这种现象想想就很明白了，双方价值不对等，这个青年对于“女神”来说就是廉价商品，自然无法博取心上人的欢心。  </p>
<p>&emsp;&emsp;当然不仅仅是恋爱关系，几乎我们生活中所有的关系都需要价值对等。比如你的一个朋友现在事业一帆风顺，取得了很大成功，而你只是一个小小的普通职员。你找你的朋友办事，一次两次人家看在朋友的情面上就帮你了，可是时间长了，这样朋友的关系自然不会长久。因为你的朋友并没有什么需要你帮助他的地方，这样就形成了关系的不对等，久而久之，这样的友谊就破碎了。  </p>
<p>&emsp;&emsp;所以请不要在鼓吹人脉了，不如把更多的时间放在投资自己这里，你的水平提升了，自然而然会接触到更加优秀的朋友。如果你只是一味地想认识“大佬”，并希望通过认识几个人就能让自己飞黄腾达，我想这是不大可能的。如果你自身的价值足够高，那么自然会吸引到志同道合的朋友。在我看来，人脉只是锦上添花的因素，而不是你成功的最重要因素。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>编程题1</title>
    <url>/2020/06/26/%E7%BC%96%E7%A8%8B%E9%A2%981/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>2013年PAT春季考试真题   </p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.   </p>
<a id="more"></a>  
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.  </p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.  </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;判断一个数列是不是上述操作出来的结果，我研究了一会，也没找到正确的数列有什么规律…既然计算机计算能力强，那就干脆一个一个模拟好了。一个循环结构，把原始的数列压入堆栈，然后从栈中弹出，和目标数列对比。如果不一样，那就FALSE。如果一样，那就对比下一个，直到全部对比完成。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>         //栈类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;         <span class="comment">//指向元素的指针</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>;        <span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">int</span> topp;       <span class="comment">//记录顶部位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> N);   <span class="comment">//根据题目所给栈大小生成栈</span></span><br><span class="line">                    <span class="comment">//为了题目计算方便，我这里把pop函数拆成两个（pop、top）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;      <span class="comment">//返回栈顶的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;     <span class="comment">//把栈顶元素弹出</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> a)</span></span>; <span class="comment">//压入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;   <span class="comment">//栈是否空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>;    <span class="comment">//栈是否满</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">asset</span><span class="params">(<span class="keyword">int</span>* original,<span class="keyword">int</span>* target,Stack S)</span></span>; <span class="comment">//评估函数，是否满足条件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* original,* target;                                <span class="comment">//原始列、目标列</span></span><br><span class="line">    <span class="keyword">bool</span>* output;                                          <span class="comment">//记录每组目标列的正确与否</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> StackSize,SequenceLength,Lines;                    <span class="comment">//栈的大小、列长、行数</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;StackSize&gt;&gt;SequenceLength&gt;&gt;Lines;</span><br><span class="line"></span><br><span class="line">    original=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(SequenceLength+<span class="number">1</span>)); <span class="comment">//初始化</span></span><br><span class="line">    target=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(SequenceLength+<span class="number">1</span>));</span><br><span class="line">    output=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*SequenceLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SequenceLength;i++) *(original+i)=i+<span class="number">1</span>;        </span><br><span class="line">    *(original+SequenceLength)=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Stack <span class="title">S</span><span class="params">(StackSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)                              <span class="comment">//输入每个目标列的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;SequenceLength;j++) <span class="built_in">cin</span>&gt;&gt;*(target+j);   </span><br><span class="line">        *(target+SequenceLength)=<span class="number">-1</span>;</span><br><span class="line">        *(output+i)=asset(original,target,S);              <span class="comment">//判断             </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(output+i)==<span class="literal">true</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;           <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">int</span> topp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> N);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">asset</span><span class="params">(<span class="keyword">int</span>* original,<span class="keyword">int</span>* target,Stack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* original,* target;</span><br><span class="line">    <span class="keyword">bool</span>* output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> StackSize,SequenceLength,Lines;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;StackSize&gt;&gt;SequenceLength&gt;&gt;Lines;</span><br><span class="line"></span><br><span class="line">    original=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(SequenceLength+<span class="number">1</span>));</span><br><span class="line">    target=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(SequenceLength+<span class="number">1</span>));</span><br><span class="line">    output=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*SequenceLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SequenceLength;i++) *(original+i)=i+<span class="number">1</span>;        </span><br><span class="line">    *(original+SequenceLength)=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Stack <span class="title">S</span><span class="params">(StackSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;SequenceLength;j++) <span class="built_in">cin</span>&gt;&gt;*(target+j);   </span><br><span class="line">        *(target+SequenceLength)=<span class="number">-1</span>;</span><br><span class="line">        *(output+i)=asset(original,target,S);                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(output+i)==<span class="literal">true</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">asset</span><span class="params">(<span class="keyword">int</span>* original,<span class="keyword">int</span>* target,Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*original==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S.in(*original);</span><br><span class="line">                original++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S.top()==*target)</span><br><span class="line">        &#123;</span><br><span class="line">            S.pop();</span><br><span class="line">            target++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.full())<span class="keyword">break</span>;</span><br><span class="line">            S.in(*original);</span><br><span class="line">            original++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*original==<span class="number">-1</span>&amp;&amp;S.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack::Stack(<span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">    p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">    <span class="built_in">max</span>=N;</span><br><span class="line">    topp=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(p+topp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    topp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stack::in</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    topp++;</span><br><span class="line">    *(p+topp)=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (topp==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::full</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (topp==<span class="built_in">max</span><span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Questions 编程题</category>
      </categories>
  </entry>
  <entry>
    <title>编程题3</title>
    <url>/2020/07/12/%E7%BC%96%E7%A8%8B%E9%A2%983/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>MOOC练习题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。  </p>
<a id="more"></a>  
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;这道题看起来确实不太难，写起来是真的让人头疼。一开始我想了一种方法：先构造一棵树，然后在读入数组，把每个数和原来的数上的树逐个比较。这样的好处是只用建一棵树，比较省内存，于是我花了大概三个小时写下了如下程序,删删改改最后只有140行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">Next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Next Left,Right;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Next p;              <span class="comment">//根节点指针</span></span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;            <span class="comment">//节点个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> N);         <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>;          <span class="comment">//构建树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span>;  <span class="comment">//插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>;        <span class="comment">//比较树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    ~Tree()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,Lines;     <span class="comment">//N节点个数，Lines比较行数</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Tree <span class="title">T</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;Lines;</span><br><span class="line">        T.<span class="built_in">set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T.check();</span><br><span class="line">            T.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tree::Tree(<span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">size</span>=N;</span><br><span class="line">    p=(Next)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="built_in">list</span>=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root;       <span class="comment">//初始化根节点</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;root;</span><br><span class="line">    *<span class="built_in">list</span>=root;</span><br><span class="line">    p-&gt;Data=root;</span><br><span class="line">    p-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"root set success "&lt;&lt;root&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> in;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in;</span><br><span class="line">        *(<span class="built_in">list</span>+i)=in;</span><br><span class="line">        insert(in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"set finished"&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::insert</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next NewRoot=p;</span><br><span class="line"></span><br><span class="line">    Next New=(Next)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));  <span class="comment">//节点初始化</span></span><br><span class="line">    New-&gt;Data=a;</span><br><span class="line">    New-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">    New-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    New-&gt;flag=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a&gt;NewRoot-&gt;Data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NewRoot-&gt;Right==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NewRoot-&gt;Right=New;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> NewRoot=NewRoot-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NewRoot-&gt;Left==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NewRoot-&gt;Left=New;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> NewRoot=NewRoot-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NewRoot=New;                                   //拼接</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;"New poin connected "&lt;&lt;NewRoot-&gt;Data;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> TF=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Next temp=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data&gt;temp-&gt;Data)            <span class="comment">//大于节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;flag==<span class="literal">false</span>)       <span class="comment">//如果节点没有被访问过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    TF=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//temp-&gt;flag=true;            //节点已访问</span></span><br><span class="line">                temp=temp-&gt;Right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data&lt;temp-&gt;Data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;flag==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    TF=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//temp-&gt;flag=true;</span></span><br><span class="line">                temp=temp-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!TF)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TF)<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp2=<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Next newone=p;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="built_in">list</span>+i)&lt;newone-&gt;Data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//newone-&gt;flag=false;</span></span><br><span class="line">                newone=newone-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*(<span class="built_in">list</span>+i)&gt;newone-&gt;Data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//newone-&gt;flag=false;</span></span><br><span class="line">                newone=newone-&gt;Right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                newone-&gt;flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;中间因为构建树的函数写错了，找错误、来来回回修改就花费了很多时间。当我写完程序满心欢喜的拿着程序提交到作业平台的时候却发现超内存了！！！<br>&emsp;&emsp;这时我的内心是崩溃的，但是不能轻易放弃！于是我又仔细读了几遍题目，想到一种算法根本不需要构建树，这种算法本质是一个递归算法，通过不断把大数组拆分成小数组然后比较。具体是这样的：假设有一个原始数组{3,1,4,2},和一个新的数组{3,4,1,2}。很明显，两个树的根节点都是3，于是我们对第一个数组做如下分割{(3),(1,2),(4)}，对第二个数组做如下分割{(3),(1,2),(4)},也就是把比根节点小的分成一组，比根节点大的分成一组，实际上也就是把树分成了左子树、右子树，然后我们递归的再比较左右子树就可以了。</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>* f,<span class="keyword">int</span> length,<span class="keyword">int</span>* s)</span></span>;                    <span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findsmall</span><span class="params">(<span class="keyword">int</span>* p,<span class="keyword">int</span> L)</span></span>;                             <span class="comment">//下面这两个函数是中间调用的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span>* small,<span class="keyword">int</span>* big,<span class="keyword">int</span>* f,<span class="keyword">int</span> L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,Lines;                                        <span class="comment">//N是长度,Line行数</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N)                                          <span class="comment">//N==0就结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;Lines;</span><br><span class="line">        <span class="keyword">int</span>* original=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);     <span class="comment">//原始列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)                          <span class="comment">//原始列初始化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;*(original+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>* temp=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);     <span class="comment">//新列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)                      <span class="comment">//新列初始化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;*(temp+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> t=check(original,N,temp);             <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">if</span> (t)<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;                   <span class="comment">//输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>* f,<span class="keyword">int</span> length,<span class="keyword">int</span>* s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findsmall</span><span class="params">(<span class="keyword">int</span>* p,<span class="keyword">int</span> L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span>* small,<span class="keyword">int</span>* big,<span class="keyword">int</span>* f,<span class="keyword">int</span> L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,Lines;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;Lines;</span><br><span class="line">        <span class="keyword">int</span>* original=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;*(original+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Lines;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>* temp=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;*(temp+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> t=check(original,N,temp);</span><br><span class="line">            <span class="keyword">if</span> (t)<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>* f,<span class="keyword">int</span> length,<span class="keyword">int</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*f==*s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> root1=*f,root2=*s;</span><br><span class="line">        <span class="keyword">int</span> small1,big1,small2,big2;</span><br><span class="line">        <span class="keyword">if</span> (root1!=root2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            small1=findsmall(f,length);</span><br><span class="line">            big1=length-small1<span class="number">-1</span>;</span><br><span class="line">            small2=findsmall(s,length);</span><br><span class="line">            big2=length-small2<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (small1!=small2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>* small1p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*small1);</span><br><span class="line">                <span class="keyword">int</span>* small2p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*small2);</span><br><span class="line">                <span class="keyword">int</span>* big1p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*big1);</span><br><span class="line">                <span class="keyword">int</span>* big2p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*big2);</span><br><span class="line"></span><br><span class="line">                create(small1p,big1p,f,length);</span><br><span class="line">                create(small2p,big2p,s,length);</span><br><span class="line">                <span class="keyword">return</span>(check(small1p,small1,small2p)&amp;&amp;check(big1p,big1,big2p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findsmall</span><span class="params">(<span class="keyword">int</span>* p,<span class="keyword">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=*p,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(p+i)&lt;root)sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span>* small,<span class="keyword">int</span>* big,<span class="keyword">int</span>* f,<span class="keyword">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root=*f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(f+i)&lt;root)</span><br><span class="line">        &#123;</span><br><span class="line">            *(small+j)=*(f+i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(f+i)&gt;root)</span><br><span class="line">        &#123;</span><br><span class="line">            *(big+k)=*(f+i);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Questions 编程题</category>
      </categories>
  </entry>
  <entry>
    <title>编程题5</title>
    <url>/2020/08/03/%E7%BC%96%E7%A8%8B%E9%A2%985/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>2005、2007年浙江大学计算机学院免试研究生上机考试题改编</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<a id="more"></a>  
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each input file contains one test case. For each test case, the first line contains N (2≤N≤10000), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure>
<p>where I stands for inputting a connection between c1 and c2; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure>
<p>where C stands for checking if it is possible to transfer files between c1 and c2; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>
<p>where S stands for stopping this case.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each C case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between c1 and c2, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are k components.” where k is the number of connected components in this network.</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;考察集合运算，题目比较简单，可以通过按秩归并和压缩路径优化算法。</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Computers(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckNetwork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="function">Computers <span class="title">C</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:C.Input();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:C.Check();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:C.CheckNetwork();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (c!=<span class="string">'S'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Computers(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckNetwork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="function">Computers <span class="title">C</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:C.Input();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:C.Check();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:C.CheckNetwork();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (c!=<span class="string">'S'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Computers::Computers(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="built_in">size</span>=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    *(p+i)=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Computers::Find</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*(p+X<span class="number">-1</span>)&lt;<span class="number">0</span>)<span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> *(p+X<span class="number">-1</span>)=Find(*(p+X<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Computers::Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(p+Root1<span class="number">-1</span>)=Root2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Computers::Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> root1,root2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    root1=Find(n);</span><br><span class="line">    root2=Find(m);</span><br><span class="line">    <span class="keyword">if</span> (root1!=root2)Union(root1,root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Computers::Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> root1,root2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    root1=Find(n);</span><br><span class="line">    root2=Find(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root1==root2)<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"yes\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"no\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Computers::CheckNetwork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(p+i)&lt;<span class="number">0</span>)counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (counter==<span class="number">1</span>)<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The network is connected."</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"There are "</span>&lt;&lt;counter&lt;&lt;<span class="string">" components."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Questions 编程题</category>
      </categories>
  </entry>
  <entry>
    <title>编程题4</title>
    <url>/2020/08/01/%E7%BC%96%E7%A8%8B%E9%A2%984/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>MOOC练习题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。</p>
<a id="more"></a>  
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;题目难度不大，只需建立一个最小堆，完成相应操作即可。主要需要完成的函数：最小堆的建立、插入元素、根据序号打印元素。</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>                        //最小堆</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;                       <span class="comment">//堆顶指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;                     <span class="comment">//堆尾</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;                     <span class="comment">//堆容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Heap(<span class="keyword">int</span> N);                  <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>;           <span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> X)</span></span>;            <span class="comment">//打印</span></span><br><span class="line">    ~Heap()&#123;&#125;;                    <span class="comment">//析构</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="function">Heap <span class="title">H</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        H.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        H.<span class="built_in">print</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Heap(<span class="keyword">int</span> N);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line">    ~Heap()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="function">Heap <span class="title">H</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        H.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        H.<span class="built_in">print</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Heap::Heap(<span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">    p=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(N+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">size</span>=N;</span><br><span class="line">    rear=<span class="number">1</span>;</span><br><span class="line">    *p=<span class="number">-10001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::insert</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=rear;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">for</span> (;*(p+temp/<span class="number">2</span>)&gt;X;temp=temp/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+temp)=*(p+temp/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *(p+temp)=X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::print</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (N/<span class="number">2</span>==<span class="number">0</span>)<span class="built_in">cout</span>&lt;&lt;*(p+N)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;*(p+N)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        N=N/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science 计算机科学</category>
        <category>Questions 编程题</category>
      </categories>
  </entry>
  <entry>
    <title>大学物理及格宝典</title>
    <url>/2020/06/24/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/</url>
    <content><![CDATA[<h2 id="考试说明"><a href="#考试说明" class="headerlink" title="考试说明"></a>考试说明</h2><p><strong>1.考试范围：</strong><br>物理学上册+物理学下册（相对论）<br><strong>2.考试题型：</strong>   </p>
<table>
<thead>
<tr>
<th>题型</th>
<th>数量</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>问答题</td>
<td>8</td>
<td>40</td>
</tr>
<tr>
<td>作图题</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>计算题</td>
<td>5</td>
<td>50</td>
</tr>
</tbody></table>
<p><strong>3.考试要求：</strong><br>&emsp;&emsp;考试时间结束后10分钟时间内，学生将书面答题内容使用手机拍照并上传到群管理员，每个班级一个监考老师，答卷命名格式为“<strong>学号-姓名-课程名称-任课教师姓名-试卷页码</strong>”；同一考生多张答卷时，将答卷放入文件夹并打包称压缩包提交，文件夹命名格式为“<strong>学号-姓名-课程名称-任课教师姓名-试卷总页数</strong>”；答卷以<strong>照片或PDF</strong>格式提交，采用<strong>竖版</strong>模式，应保证试卷电子版清晰可辨。<br><strong>4.考试时间：</strong><br><font color=red>6.28 上午8:30-10:30</font></p>
<a id="more"></a>    
<p><img src="/images/%E5%8F%8A%E6%A0%BC%E4%B8%87%E5%B2%81.jpg" alt="1"></p>
<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><h4 id="第一章-质点运动学"><a href="#第一章-质点运动学" class="headerlink" title="第一章 质点运动学"></a>第一章 质点运动学</h4><p><strong>1.知识点：</strong><br>①描述质点运动的四个物理量：位矢r，位移∆r，速度υ，加速度a<br>②质点运动学<br>③圆周运动<br><strong>2.考点：</strong><br>①质点运动学：<br>已知a(υ)、a(r)求相关物理量（一般用变量替换）<br><strong>例题：</strong>  </p>
<table>
<thead>
<tr>
<th>书名</th>
<th>页数</th>
<th>题号</th>
</tr>
</thead>
<tbody><tr>
<td>大学物理辅导与练习</td>
<td>3</td>
<td>例1-3</td>
</tr>
<tr>
<td>大学物理辅导与练习</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>物理学（上册）</td>
<td>9</td>
<td>例2</td>
</tr>
</tbody></table>
<p>②圆周运动：<br><strong>例题：</strong>  </p>
<p>|书名|页数|题号<br>|-|-|-|-|<br>大学物理辅导与练习|3|例1-4</p>
<hr>
<h4 id="第二章-牛顿运动学"><a href="#第二章-牛顿运动学" class="headerlink" title="第二章 牛顿运动学"></a>第二章 牛顿运动学</h4><p><strong>1.知识点</strong><br>①牛顿运动定律<br>②常见力（万有引力、弹性力、摩擦力）<br><strong>2.考点：</strong><br>已知力，求运动。如果涉及两个以上质点，采用“隔离体法”。<br><strong>例题：</strong>  </p>
<table>
<thead>
<tr>
<th>书名</th>
<th>页数</th>
<th>题号</th>
</tr>
</thead>
<tbody><tr>
<td>物理学（上册）</td>
<td>40</td>
<td>例1</td>
</tr>
<tr>
<td>物理学（上册）</td>
<td>45</td>
<td>例6</td>
</tr>
<tr>
<td>大学物理辅导与练习</td>
<td>11</td>
<td>例2-3</td>
</tr>
</tbody></table>
<hr>
<h4 id="第三章-动量守恒定律和能量守恒定律"><a href="#第三章-动量守恒定律和能量守恒定律" class="headerlink" title="第三章 动量守恒定律和能量守恒定律"></a>第三章 动量守恒定律和能量守恒定律</h4><p><strong>1.知识点</strong><br>①冲量、动量<br>②功   </p>
]]></content>
      <categories>
        <category>其他</category>
        <category>大一下考试资料</category>
      </categories>
  </entry>
  <entry>
    <title>古文观止-郑伯克段于鄢</title>
    <url>/2020/06/23/guwenguanzhi1/</url>
    <content><![CDATA[<h2 id="左传"><a href="#左传" class="headerlink" title="左传"></a>左传</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作者</th>
<th align="center">时间</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">《左传》</td>
<td align="center">左丘明</td>
<td align="center">战国初年</td>
<td align="center">战争</td>
</tr>
</tbody></table>
<p><img src="/images/zuozhuan2.jpg" alt="1"><br>&emsp;&emsp;《左传》，相传为左丘明著。原名《左氏春秋》，汉代改称《春秋左氏传》，简称《左传》。它是<strong>中国古代第一部叙事完备的编年体史书</strong>，更是先秦散文著作的代表，它标志着我国叙事散文的成熟。它与《公羊传》、《谷梁传》合称“春秋三传”。</p>
<a id="more"></a>
<p>&emsp;&emsp;《左传》作为一部<strong>史书</strong>记录了从鲁隐公元年（前 722）至鲁哀公二十七年（前 468）之间发生的史诗，记录了各国争霸的战争史。同时《左传》也是一部优秀的<strong>文学著作</strong>，其擅长描写战争、刻画人物，是中国古代散文发展到了一个新的高度，《左传》被认为是中国古代散文的一大源头。</p>
<h2 id="郑伯克段于鄢"><a href="#郑伯克段于鄢" class="headerlink" title="郑伯克段于鄢"></a>郑伯克段于鄢</h2><p><img src="/images/%E5%B7%A6%E4%BC%A01.jpg" alt="1"></p>
<h4 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h4><blockquote>
<p>&emsp;&emsp;初，郑武公娶于申，曰武姜。生庄公及共叔段。庄公寤生，惊姜氏，故名曰“寤生”，遂恶之。爱共叔段，欲立之，亟请于武公，公弗许。及庄公即位，为之请制。公曰：“制，岩邑也，虢叔死焉，佗邑唯命。”请京，使居之，谓之“京城大叔”。<br>&emsp;&emsp;祭仲曰：“都，城过百雉，国之害也。先王之制：大都，不过参国之一；中，五之一；小，九之一。今京不度，非制也，君将不堪。”公曰：“姜氏欲之，焉辟害？”对曰：“姜氏何厌之有？不如早为之所，无使滋蔓。蔓，难图也。蔓草犹不可除，况君之宠弟乎？”公曰：“多行不义，必自毙，子姑待之。”<br>&emsp;&emsp;既而大叔命西鄙、北鄙贰于己。公子吕曰：“国不堪贰，君将若之何？欲与大叔，臣请事之；若弗与，则请除之，无生民心。”公曰：“无庸，将自及。”大叔又收贰以为己邑，至于廪延。子封曰：“可矣。厚将得众。”公曰：“不义不昵，厚将崩。”<br>&emsp;&emsp;大叔完聚，缮甲兵，具卒乘，将袭郑。夫人将启之。公闻其期，曰：“可矣！”命子封帅车二百乘以伐京。京叛大叔段。段入于鄢“。公伐诸鄢。五月辛丑，大叔出奔共。<br>&emsp;&emsp;遂置姜氏于城颍，而誓之日：“不及黄泉，无相见也。”既而悔之。<br>&emsp;&emsp;颍考叔为颍谷封人，闻之，有献于公。公赐之食。食舍肉。公问之，对曰：“小人有母，皆尝小人之食矣，未尝君之羹。请以遗之。”公曰：“尔有母遗，繄我独无！”颖考叔曰：“敢问何谓也？”公语之故，且告之悔。对曰：“君何患焉？若阙地及泉，隧而相见，其谁曰不然？”公从之。公入而赋：“大隧之中，其乐也融融！”姜出而赋：“大隧之外，其乐也泄泄！”遂为母子如初。<br>&emsp;&emsp;君子曰：“颖考叔，纯孝也。爱其母，施及庄公。《诗》曰：‘孝子不匮，永锡尔类。’其是之谓乎？”</p>
</blockquote>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><ul>
<li>寤生：生产时婴儿脚先出来  </li>
<li>亟：多次、屡次  </li>
<li>岩邑：险要的城邑  </li>
<li>毙：倒下  </li>
<li>崩：山陵崩塌，这里指垮台  </li>
<li>融融、泄泄：形容快乐的样子  </li>
</ul>
<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>&emsp;&emsp;郑武公娶了武姜，生了两个孩子，哥哥是庄公，弟弟是共段叔。因为庄公出生时脚先出来，于是姜氏十分嫌恶他。等到庄公即位之后，姜氏为共段叔请求领地，于是庄公便把京给了共段叔作为他的领地。得到领地之后，姜氏和共段叔并没有满足，他们聚集兵力、修缮城墙企图进攻郑庄公。郑庄公知道这件事情之后，很多大夫都劝他先下手，如果任由其发展将来就很难对付了。郑庄公却不这么认为，他说没有正义，得不到拥护，实力再雄厚最终也会垮台。果然，共段叔打算偷袭庄公，姜氏也偷偷打开城门让共段叔进攻，但是没想到京邑人反叛，共段叔不得不逃到了共邑躲了起来。</p>
<p><img src="/images/zuozhuan3.jpg" alt="1"><br>&emsp;&emsp;郑庄公十分生气，于是把姜氏安置到了城颖，并且发誓不到黄泉绝不相见，但是他说完不就便后悔了。颍考叔听闻这件事，便向庄公献礼，庄公宴请他，吃饭时，颍考叔把肉留在一旁，庄公十分好奇他为什么这么做，于是颍考叔说他的母亲还没有尝过这样的肉羹，他要留给他的母亲。庄公听了他的一番话之后十分感动，但是哀叹道他已经没有母亲可以侍奉了。颍考叔告诉了郑庄公一个方法，从地上一直往下挖，一直挖到泉水，你们母子在所挖的隧道中相见，那么谁又能说不是呢？最终庄公与姜氏在隧道中相见，他们的关系又恢复了。</p>
]]></content>
      <categories>
        <category>Reading Notes 读书笔记</category>
        <category>古文观止</category>
        <category>左传</category>
      </categories>
  </entry>
  <entry>
    <title>高等代数计算题汇总</title>
    <url>/2020/06/25/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E8%AE%A1%E7%AE%97%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><img src="/images/%E7%BB%9D%E4%B8%8D%E6%8C%82%E7%A7%91.jpg" alt="1"></p>
<a id="more"></a>  

<h2 id="第五章、二次型"><a href="#第五章、二次型" class="headerlink" title="第五章、二次型"></a>第五章、二次型</h2><p>题型：<strong>化二次型为标准型（规范型）</strong><br>方法：<br>①配方法<br>②初等变换法<br>例题：  </p>
<table>
<thead>
<tr>
<th>来源</th>
<th>页数</th>
<th>题号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>教材</td>
<td>157</td>
<td>1</td>
<td>无</td>
</tr>
<tr>
<td>教材</td>
<td>158</td>
<td>1</td>
<td>无</td>
</tr>
<tr>
<td>习题课</td>
<td>10</td>
<td>1、2、3</td>
<td>无</td>
</tr>
<tr>
<td>单元测试</td>
<td>2</td>
<td>二、三</td>
<td>无</td>
</tr>
</tbody></table>
<!-- more -->  
<p>题型：<strong>判断二次型是否正定</strong><br>方法：<br>①顺序主子式<br>②化为标准型（规范型）<br>例题：  </p>
<table>
<thead>
<tr>
<th>来源</th>
<th>页数</th>
<th>题号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>教材</td>
<td>157</td>
<td>7</td>
<td>无</td>
</tr>
<tr>
<td>教材</td>
<td>158</td>
<td>8</td>
<td>无</td>
</tr>
<tr>
<td>习题课</td>
<td>10</td>
<td>4</td>
<td>无</td>
</tr>
<tr>
<td>单元测试</td>
<td>2</td>
<td>四</td>
<td>与上题类似</td>
</tr>
</tbody></table>
<hr>
<h2 id="第六章、线性空间"><a href="#第六章、线性空间" class="headerlink" title="第六章、线性空间"></a>第六章、线性空间</h2><p>题型：<strong>求过渡矩阵、基下坐标</strong><br>方法：<br>直接计算<br>例题：  </p>
<table>
<thead>
<tr>
<th>来源</th>
<th>页数</th>
<th>题号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>教材</td>
<td>182</td>
<td>9、10</td>
<td>无</td>
</tr>
<tr>
<td>习题课一</td>
<td>7</td>
<td>三（1）</td>
<td>无</td>
</tr>
<tr>
<td>单元测试</td>
<td>4</td>
<td>五</td>
<td>无</td>
</tr>
</tbody></table>
<p>题型：<strong>基、维数</strong><br>方法：<br>维数：矩阵的秩<br>基：极大线性无关组<br>写出矩阵，行约化  0<br>例题：  </p>
<table>
<thead>
<tr>
<th>来源</th>
<th>页数</th>
<th>题号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>教材</td>
<td>183</td>
<td>16</td>
<td>无</td>
</tr>
<tr>
<td>教材</td>
<td>183</td>
<td>17</td>
<td>无</td>
</tr>
<tr>
<td>单元测试</td>
<td>2</td>
<td>三</td>
<td>无</td>
</tr>
</tbody></table>
<p>题型：<strong>交（和）的基、维数</strong><br>方法：<br>维数公式：维 (交) + 维 (和) = 维 (V1) + 维 (V2)<br>和：L (a1, a2) + L (b1, b2) = L (a1, a2, b1, b2)<br>交：设a是交空间中的向量，a= x1<em>a1 + x2</em>a2 = y1<em>b1 + y2</em>b2，解方程，求出向量<br>例题：  </p>
<table>
<thead>
<tr>
<th>来源</th>
<th>页数</th>
<th>题号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>教材</td>
<td>183</td>
<td>18</td>
<td>无</td>
</tr>
<tr>
<td>习题课二</td>
<td>15</td>
<td>三（1）</td>
<td>无</td>
</tr>
<tr>
<td>单元测试</td>
<td>3</td>
<td>四</td>
<td>无</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>其他</category>
        <category>大一下考试资料</category>
      </categories>
  </entry>
</search>
